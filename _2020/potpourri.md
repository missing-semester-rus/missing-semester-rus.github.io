---
layout: lecture
title: "Potpourri"
date: 2020-01-29
ready: true
video:
  aspect: 56.25
  id: JZDt-PRq0uo
---

## Содержание

- [Содержание](#содержание)
- [Настройка клавиатуры](#настройка-клавиатуры)
- [Демоны (Daemons)](#демоны-daemons)
- [FUSE](#fuse)
- [Резервное копирование](#резервное-копирование)
- [API](#api)
- [Общие флаги/шаблоны командной строки](#общие-флагишаблоны-командной-строки)
- [Оконные менеджеры](#оконные-менеджеры)
- [VPN](#vpn)
- [Markdown](#markdown)
- [Hammerspoon (автоматизация рабочего стола на macOS)](#hammerspoon-автоматизация-рабочего-стола-на-macos)
  - [Resources](#resources)
- [Booting + Live USBs](#booting--live-usbs)
- [Docker, Vagrant, VMs, Cloud, OpenStack](#docker-vagrant-vms-cloud-openstack)
- [Программирование в ноутбуках](#программирование-в-ноутбуках)
- [GitHub](#github)

## Настройка клавиатуры

Для Вас, как для программиста, главным способом ввода является клавиатура. Как и практически все на Вашем компьютере, она настраивается (и стоит того, чтобы ее настроить). 

Базовым изменением является переопределение клавиш. 
Обычно для этого потребуется некоторая программа, которая воспринимает нажатие клавиш, перехватывает некоторое действие и заменяет его на другое в соответствии с другой клавишей. Например:
- Заменить Caps Lock на Ctrl или Escape. Мы (инструкторы) крайне рекомендуем эту настройку, так как Caps Lock находится в очень удобном месте и редко используется.
- Заменить PrtSc на play/pause для музыки. Большинство ОС имеют play/pause клавишу.
- Поменять местами Ctrl и Meta (Windows or Command) клавишу.

Также Вы можете присвоить клавишам произвольные команды на свой вкус. Это полезно в контексте основных задач, с которыми Вы сталкиваетесь. Вот некоторые примеры:
- Открыть новое окно терминала или браузера.
- Вставить какой-нибудь специфический текст, например, длинный email адрес или MIT ID номер.
- Включение спящего режима компьютера или монитора.

Существуют еще более сложные модификации, которые Вы можете настроить:
- Переопределение последовательности клавиш, например, нажатие shift 5 раз включает Caps Lock.
- Настройка клавиши на нажатие и удержание, например, Caps Lock переопределен на Esc при быстром нажатии и на Ctrl при удержании. 
- Сделать настройку специфичной для клавиатуры или программного обеспечения. 

Некоторые ресурсы для ознакомления с данной темой:
- macOS - [karabiner-elements](https://pqrs.org/osx/karabiner/), [skhd](https://github.com/koekeishiya/skhd) или [BetterTouchTool](https://folivora.ai/)
- Linux - [xmodmap](https://wiki.archlinux.org/index.php/Xmodmap) или [Autokey](https://github.com/autokey/autokey)
- Windows - [AutoHotkey](https://www.autohotkey.com/) или [SharpKeys](https://www.randyrants.com/category/sharpkeys/)
- QMK - Если Ваша клавиатура поддерживает кастомную прошивку, можно использовать [QMK](https://docs.qmk.fm/) для настройки самого устройства, так что Ваши переопредления будут работать для любого ПК, с которым Вы используете данную клавиатуру. 

## Демоны (Daemons)

Вы, вероятно, уже знакомы с понятием демонов, даже если это слово кажется новым. 
Большинство компьютеров имеют ряд процессов, которые всегда работают в фоновом режиме, 
а не ждут, когда пользователь их запустит и начнет с ними взаимодействовать. Эти процессы называются демонами, 
и программы, которые работают как демоны, часто заканчиваются на `d`, чтобы указать на это. 
Например, `sshd`, демон SSH, отвечает за обработку входящих запросов SSH и проверку того, 
что удаленный пользователь имеет необходимые учетные данные для входа в систему.

В Linux `systemd` (системный демон) - это наиболее распространенное решение для запуска 
и настройки процессов-демонов. Вы можете выполнить `systemctl status`, чтобы перечислить 
текущие работающие демоны. Большинство из них могут показаться незнакомыми, но они отвечают 
за основные части системы, такие как управление сетью, решение DNS-запросов или отображение графического интерфейса системы. 
С Systemd можно взаимодействовать с помощью команды `systemctl`, 
чтобы `enable`, `disable`, `start`, `stop`, `restart` или проверить `status` сервисов.

Что более интересно, `systemd` имеет доступный интерфейс для настройки и включения новых демонов (или сервисов). 
Ниже приведен пример демона для запуска простого приложения Python. Мы не будем вдаваться в 
подробности, но, как вы можете видеть, большинство полей довольно понятны.

```ini
# /etc/systemd/system/myapp.service
[Unit]
Description=My Custom App
After=network.target

[Service]
User=foo
Group=foo
WorkingDirectory=/home/foo/projects/mydaemon
ExecStart=/usr/bin/local/python3.7 app.py
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

Также, если вы просто хотите запустить какую-то программу с заданной частотой, вам не нужно создавать собственного демона, вы можете использовать [`cron`](https://www.man7.org/linux/man-pages/man8/cron.8.html), демон, который ваша система уже запускает для выполнения запланированных задач.

## FUSE

Современные программные системы обычно состоят из меньших строительных блоков, которые объединяются вместе.
Ваша операционная система поддерживает использование различных файловых систем, потому что есть общий язык операций, которые поддерживает файловая система.
Например, когда вы запускаете `touch` для создания файла, `touch` выполняет системный вызов к ядру для создания файла, а ядро выполняет соответствующий вызов файловой системе для создания данного файла.
Однако стоит отметить, что файловые системы UNIX традиционно реализуются как модули ядра, и только ядро может выполнять вызовы файловой системы.

[FUSE](https://en.wikipedia.org/wiki/Filesystem_in_Userspace) (Filesystem in User Space, Файловая система в пользовательском пространстве) позволяет реализовывать файловые системы с помощью пользовательской программы. FUSE позволяет пользователям запускать код пользовательского пространства для вызовов файловой системы, а затем связывает необходимые вызовы с интерфейсами ядра.
На практике это означает, что пользователи могут реализовывать произвольную функциональность для вызовов файловой системы.

Например, FUSE можно использовать так, что при выполнении операции в виртуальной файловой системе, эта операция перенаправляется через SSH на удаленную машину, выполняется там, и результат возвращается обратно к вам.
Таким образом, локальные программы могут видеть файл, как если бы он был на вашем компьютере, хотя на самом деле он находится на удаленном сервере.
Это в основном то, что делает `sshfs`.

Некоторые интересные примеры файловых систем FUSE:
- [sshfs](https://github.com/libfuse/sshfs) - Открывайте удаленные файлы/папки локально через SSH-соединение.
- [rclone](https://rclone.org/commands/rclone_mount/) - Монтируйте облачные хранилища данных, такие как Dropbox, GDrive, Amazon S3 или Google Cloud Storage, и открывайте данные локально.
- [gocryptfs](https://nuetzlich.net/gocryptfs/) - Система шифрования. Файлы хранятся в зашифрованном виде, но после монтирования ФС они появляются как обычный текст в точке монтирования.
- [kbfs](https://keybase.io/docs/kbfs) - Распределенная файловая система со сквозным шифрованием. У вас могут быть приватные, общие и публичные папки.
- [borgbackup](https://borgbackup.readthedocs.io/en/stable/usage/mount.html) - Монтируйте свои дедуплицированные, сжатые и зашифрованные резервные копии для удобства просмотра.


## Резервное копирование

Любые данные, которые вы не резервировали, могут в любой момент исчезнуть навсегда.
Копировать данные легко, но сложно надежно резервировать данные.
Вот несколько основных принципов резервного копирования и подводные камни некоторых подходов.

Во-первых, копия данных на том же диске не является резервной копией, потому что диск является единой точкой отказа. Аналогично, внешний диск у вас дома также является слабым решением для резервного копирования, поскольку он может быть потерян при пожаре/грабеже и т.д. Вместо этого рекомендуется иметь резервную копию в другом месте.

Синхронизация не является резервным копированием. Например, Dropbox/GDrive - удобные решения, но когда данные стираются или повреждаются, эти повреждения распространяются на синхронизированные файлы. По той же причине решения для зеркалирования дисков, такие как RAID, не являются резервными копиями. Они не помогают, если данные удаляются, повреждаются или шифруются вирусом-вымогателем.

Некоторые основные функции хороших решений для резервного копирования - это версионирование, дедупликация и безопасность.
Версионирование резервных копий гарантирует, что вы можете получить доступ к истории изменений и эффективно восстановить файлы.
Эффективные решения для резервного копирования используют дедупликацию данных, чтобы хранить только инкрементные изменения и снизить накладные расходы на хранение.
Что касается безопасности, вы должны спросить себя, что нужно знать/иметь, чтобы прочитать ваши данные и, что более важно, удалить все ваши данные и связанные резервные копии.
Наконец, слепое доверие резервным копиям - ужасная идея, и вы должны регулярно проверять, что вы можете использовать их для восстановления данных.

Резервное копирование выходит за рамки локальных файлов на вашем компьютере.
Учитывая значительный рост веб-приложений, большое количество ваших данных хранится только в облаке.
Например, ваша веб-почта, фотографии в социальных сетях, плейлисты музыки в стриминговых сервисах или онлайн-документы исчезают, если вы потеряете доступ к соответствующим аккаунтам.
Наличие офлайн-копии этой информации - это правильный подход, и вы можете найти онлайн-инструменты, которые люди создали для извлечения данных и их сохранения.

Для более подробного объяснения см. лекционные материалы 2019 года о [Резервном копировании](/2019/backups).


## API

На этом уроке мы много говорили о том, как использовать компьютер эффективно при
решении _локальных_ задач. Вы также обнаружите, что многие из этих уроков
применимы и при работе в сети Интернет. Большинство онлайн-сервисов
предоставляют "API", которые позволяют получить доступ к данным сервисов
"программно". Например, правительство США предоставляет API, с помощью которого
можно узнать прогноз погоды, таким образом вы можете с легкостью получить данные
в командной оболочке (shell).

Большинство API имеют схожий между собой формат. Это структурированные URL-адреса,
часто расположенные на `api.<сервис>.com`, в которых путь и параметры запроса указывают,
какие вернуть данные или какое выполнить действие. Например, чтобы узнать
прогноз погоды некоторого местоположения в США, нужно отправить GET запрос
(например, с помощью утилиты `curl`) на https://api.weather.gov/points/42.3604,-71.094.
Сам ответ содержит множество других URL-адресов, которые позволяют получить
конкретные прогнозы для указанного региона. Обычно ответы форматируются в JSON,
который затем можно передать утилите типа [`jq`](https://stedolan.github.io/jq/),
чтобы извлечь интересующую информацию.

Некоторые API требуют аутентификации, обычно принимающей форму секретного _токена_
(token), который необходимо включить в запрос. Прочтите документацию API сервиса,
который собираетесь использовать, чтобы узнать используемую технологию аутентификации.
"[OAuth](https://www.oauth.com/)" — протокол, который будет вам часто встречаться.
По своей сути OAuth — это способ предоставить токены, которые могут действовать
"от вашего имени" в рассматриваемом сервисе для выполнения определенных задач.
Имейте в виду, что эти токены являются _секретными_, и каждый, кто получит доступ
к вашему токену, сможет совершать любые действия, использующие токен, под _вашей_
учетной записью!

[IFTTT](https://ifttt.com/) — сайт и сервис, завязанный на идее использования API.
Он позволяет объединять события различных сервисов в произвольную цепочку. Стоит
взглянуть!

## Общие флаги/шаблоны командной строки

Инструменты командной строки очень разные, и перед их использованием 
вам часто придется просматривать их `man` страницы. Однако у них есть некоторые общие 
особенности, о которых полезно знать:

 - Большинство инструментов поддерживают флаг `--help` для отображения краткой инструкции по использованию инструмента.
 - Многие инструменты, которые могут вызвать необратимые изменения, поддерживают понятие "сухого прогона" (dry-run), в котором они только печатают то, что они _собирались сделать_, но на самом деле не производят изменения. Аналогично, у них часто есть флаг "интерактивный", который будет запрашивать у вас подтверждение для каждого необратимого действия.
 - Обычно вы можете использовать `--version` или `-V`, чтобы программа напечатала свою версию (удобно для сообщения об ошибках!).
 - Почти все инструменты имеют флаг `--verbose` или `-v` для вывода более подробной информации. Обычно вы можете включить флаг несколько раз (`-vvv`), чтобы получить _более_ подробный вывод, что может быть полезно для отладки. Аналогично, у многих инструментов есть флаг `--quiet` для вывода информации только в случае ошибки.
 - Во многих инструментах `-` вместо имени файла означает "стандартный ввод" или "стандартный вывод", в зависимости от аргумента.
 - Потенциально разрушительные инструменты обычно не рекурсивны по умолчанию, но поддерживают флаг "рекурсивный" (часто `-r`), чтобы сделать их рекурсивными.
 - Иногда вы хотите передать что-то, что _выглядит_ как флаг, в качестве обычного аргумента. Например, представьте, что вы хотите удалить файл с именем `-r`. Или вы хотите запустить одну программу "через" другую, например `ssh machine foo`, и вы хотите передать флаг "внутренней" программе (`foo`). Специальный аргумент `--` заставляет программу _прекратить_ обработку флагов и опций (вещей, начинающихся с `-`) в том, что следует, позволяя вам передавать вещи, которые выглядят как флаги, без их интерпретации как таковых: `rm -- -r` или `ssh machine --for-ssh -- foo --for-foo`.

## Оконные менеджеры

Большинство из вас привыкли использовать оконный менеджер, позволяющий
перетаскивать окна программ, который по умолчанию поставляется с Windows, macOS
и Ubuntu. Окна можно накладывать друг на друга, изменять их размер, перемещать в
любую часть экрана. Но эти возможности характеризуют лишь один _тип_ оконного
менеджера, который называется "плавающим" (floating). Существует множество
других типов, в особенности для Linux. Распространенной альтернативой является
"плиточный" (tiling) оконный менеджер. Плиточный тип не позволяет окнам
перекрывать друг друга, таким образом окна располагаются на экране, как панели в
tmux. С плиточным менеджером экран всегда заполнен открытыми окнами, располагая
их в соответствии с заданным _макетом_. Если открыто только одно окно, оно будет
занимать весь экран. Открытие второго окна заставляет первое подвинуться, и
теперь окна занимают по половине (или 1/3 и 2/3) экрана. Открывая третье,
существующие окна снова поджимаются, чтобы вместить нового соседа. Как и в
случае с панелями tmux, по окнам можно перемещаться, изменять их размер
переставлять, используя лишь клавиатуру. Их стоит попробовать!

## VPN

VPN (Virtual Private Network) нынче в моде, но не совсем ясно, существует
ли вообще [причина для этого](https://gist.github.com/joepie91/5a9909939e6ce7d09e29).
Вы должны быть осведомлены о том, что VPN делает и что не делает. VPN в 
лучшем случае _реально_ просто способ поменять провайдера, и весь Ваш трафик
будет выглядеть так, как будто он исходит от VPN провайдера вместо Вашей
"настоящей" локации, и сеть, к которой Вы подключены, будет видеть только
этот "зашифрованный" трафик.

Несмотря на привлекательность данной идеи, держите в уме, что когда Вы
используете VPN, все Ваши действия доверяются не Вашему текущему интернет-провайдеру, 
а провайдеру VPN. Все, что может увидеть Ваш интернет-провайдер,
теперь _вместо_ него видит провайдер VPN. И только если Вы доверяете ему 
_больше_, чем интернет-провайдеру, Вы в выигрыше, а в противном случае
результат для Вас сомнителен. Если Вы подключены к какому-нибудь сомнительному
публичному Wi-Fi в аэропорту, тогда скорее всего Вы не особо доверяете соединению,
но будучи дома стоит подумать дважды. 

Также Вы должны знать, что в наши дни большая часть трафика, по крайней
мере деликатного характера, _уже_ зашифрована с помощью HTTPS или TLS. 
И поэтому от того, на "плохой" Вы сети или нет, мало что зависит - оператор
сети будет знать только о том, с какими серверами Вы взаимодействуете, но
не о самих данных, которыми Вы обмениваетесь. 

Обратите внимание, я сказал "в лучшем случае" выше. VPN провайдеры совсем
не гнушаются настраивать свой софт таким образом, чтобы шифрование было 
слабее или даже совсем отсутствовало. Некоторые VPN провайдеры попросту 
злоумышленники (или по крайней мере, оппортунисты), и будут записывать весь
Ваш трафик и вероятно продавать информацию третьим лицам. Выбрать плохого
VPN провайдера обычно намного хуже, чем вообще не использовать VPN.

В крайнем случае, у MIT есть [свой VPN](https://ist.mit.edu/vpn) для студентов,
так что возможно Вам стоит взглянуть. Также если Вы собрались запустить свой,
обратите внимание на [WireGuard](https://www.wireguard.com/).

## Markdown

Скорее всего на карьерном пути Вы столкнетесь с написанием текстов. 
И как правило хочется иметь возможность разметить текст простым
способом. Например, сделать текст жирным или курсивом, добавить
заголовки, ссылки, куски кода. Вместо использования таких тяжелых
инструментов, как Word или LaTeX, предлагаем Вам попробовать облегченный
язык разметки [Markdown](https://commonmark.org/help/).
    
Вероятно Вы уже сталкивались с Markdown или по крайней мере с каким-то
его вариантом. Так или иначе он частично используется и поддерживается
практически везде, даже если не конкретно под своим именем. По своей сути,
Markdown - это попытка конвертировать в код способ, которым люди обычно
размечают текст, когда пишут простые текстовые документы. Акцент (*курсив*)
добавляется при помощи `*` перед словом и после него. Сильный акцент 
(**жирный**) - аналогично с помощью `**`. Строки, начинающиеся с `#`, 
являются заголовками (причем количество `#`отражает уровень подзаголовка).
Любая строка, начинающаяся с `-`, это пункт маркированного списка, а с 
номером и `.` - нумерованного. Бэктик (обратный апостроф) применяется
для выделения строки кода, а если Вам нужно вставить блок кода, используйте
тройные бэктики:

    ```
    код начинается тут 
    ```

Для добавления ссылки поместите _текст_  для ссылки в квадратные скобки,
а сам URL сразу после в круглых скобках: `[name](url)`. Markdown довольно
просто начать пользоваться, и Вы можете использовать его практически везде.
На самом деле, заметки к этой и другим лекциям написаны на Markdown, и Вы 
можете посмотреть на "сырой" Markdown [здесь](https://raw.githubusercontent.com/missing-semester/missing-semester/master/_2020/potpourri.md).


## Hammerspoon (автоматизация рабочего стола на macOS)

[Hammerspoon](https://www.hammerspoon.org/) является фреймворком для автоматизации рабочего стола
для macOS. Он позволяет вам писать скрипты на Lua, которые взаимодействуют с операционной системой,
позволяя вам взаимодействовать с клавиатурой/мышью, окнами,
дисплеями, файловой системой и многим другим.

Некоторые примеры того, что вы можете сделать с Hammerspoon:

- Привязать горячие клавиши для перемещения окон в определенные места
- Создать кнопку в строке меню, которая автоматически располагает окна в определенном виде
- Отключить звук ваших динамиков, когда вы приходите в лабораторию (через определение Wi-Fi сети)
- Показать вам предупреждение, если вы случайно взяли блок питания вашего друга

Верхнеуровнево, Hammerspoon позволяет вам запускать произвольный код Lua, 
привязанный к кнопкам меню, нажатиям клавиш или событиям, и Hammerspoon предоставляет обширную библиотеку 
для взаимодействия с системой, поэтому нет предела тому, что вы можете с ним сделать. 
Многие люди опубликовали свои конфигурации Hammerspoon, поэтому вы можете найти то, что вам нужно, 
просто поискав в интернете, но вы всегда можете написать свой собственный код с нуля.

### Resources

- [Getting Started with Hammerspoon](https://www.hammerspoon.org/go/)
- [Sample configurations](https://github.com/Hammerspoon/hammerspoon/wiki/Sample-Configurations)
- [Anish's Hammerspoon config](https://github.com/anishathalye/dotfiles-local/tree/mac/hammerspoon)

## Booting + Live USBs

При включении компьютера, до загрузки операционной системы, 
[BIOS](https://en.wikipedia.org/wiki/BIOS)/[UEFI](https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface) 
инициализирует систему. Во время этого процесса вы можете нажать определенную комбинацию клавиш, 
чтобы настроить это программное обеспечение. Например, ваш компьютер может сказать что-то вроде 
"Нажмите F9, чтобы настроить BIOS. Нажмите F12, чтобы войти в меню загрузки." 
во время процесса загрузки. Вы можете конфигурировать все виды настроек, 
связанные с аппаратным обеспечением, в меню BIOS. Вы также можете войти в меню загрузки, 
чтобы загрузиться с альтернативного устройства вместо вашего жесткого диска.

[Live USB](https://en.wikipedia.org/wiki/Live_USB) - это USB флеш-накопители, содержащие операционную систему. 
Вы можете создать один из них, скачав операционную систему (например, дистрибутив Linux) и записав ее на флеш-накопитель. 
Этот процесс немного сложнее, чем просто копирование файла `.iso` на диск. 
Существуют инструменты, такие как [UNetbootin](https://unetbootin.github.io/), которые помогают 
вам создавать Live USB.

Live USB полезны для самых разных целей. Среди прочего, если вы сломаете свою существующую операционную систему так, 
что она больше не загружается, вы можете использовать Live USB для восстановления данных или исправления операционной системы.

## Docker, Vagrant, VMs, Cloud, OpenStack

[Виртуальные машины](https://en.wikipedia.org/wiki/Virtual_machine) и подобные инструменты, 
такие как контейнеры, позволяют вам эмулировать целую компьютерную систему. 
Это может быть полезно для создания изолированной среды для тестирования, разработки или исследования 
(например, запуска потенциально вредоносного кода).

[Vagrant](https://www.vagrantup.com/) - это инструмент, который позволяет 
вам описывать конфигурации машин (операционная система, службы, пакеты и т.д.) в коде, 
а затем создавать виртуальные машины с помощью простой команды `vagrant up`. 
[Docker](https://www.docker.com/) концептуально похож, но использует контейнеры.

Вы также можете арендовать виртуальные машины в облаке, и это хороший способ получить мгновенный доступ к:

- Дешевой и всегда включенной машине с публичным IP-адресом, используемой для хостинга сервисов
- Машине с большим количеством CPU, диска, RAM и/или GPU
- Гораздо большему количеству машин, чем у вас есть физический доступ (тарификация часто идет по секундам, поэтому если вам нужно много вычислительной мощности на короткое время, вполне реально арендовать 1000 компьютеров на пару минут)

Популярные сервисы включают [Amazon AWS](https://aws.amazon.com/), [Google Cloud](https://cloud.google.com/), [Microsoft Azure](https://azure.microsoft.com), [DigitalOcean](https://www.digitalocean.com/).

## Программирование в ноутбуках

[Среды программирования в ноутбуках](https://en.wikipedia.org/wiki/Notebook_interface) могут быть очень 
удобны для выполнения определенных типов интерактивной или исследовательской разработки. 
Возможно, самой популярной средой программирования в ноутбуках сегодня является 
[Jupyter](https://jupyter.org/), для Python (и нескольких других языков). 
[Wolfram Mathematica](https://www.wolfram.com/mathematica/) - это еще одна среда программирования в 
ноутбуках, которая отлично подходит для выполнения программирования, ориентированного на математику.

## GitHub

[GitHub](https://github.com/) - одна из самых популярных платформ для разработки
открытого программного обеспечения (open-source software). Множество инструментов,
о которых мы говорили, от [vim](https://github.com/vim/vim) до [Hammerspoon](https://github.com/Hammerspoon/hammerspoon),
размещены на GitHub. Довольно легко начать вносить свой вклад в open-source, чтобы
сделать лучше инструменты, которыми мы пользуемся ежедневно. 

Есть два главных способа участия в проектах на GitHub:

- Создать [issue](https://help.github.com/en/github/managing-your-work-on-github/creating-an-issue).
Таким образом можно сообщить о баге или запросить новую функцию. Ни то, ни другое
не требует чтения или написания кода, так что сделать это довольно легко. Качественные
отчеты о багах могут оказаться очень ценными для разработчиков. Участие в уже существующих
обсуждениях тоже может быть полезным.
- Внести свой код с помощью [pull
request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/about-pull-requests).
Это естественно требует большего вовлечения в проект, нежели issue. Вы можете скопировать 
[fork](https://help.github.com/en/github/getting-started-with-github/fork-a-repo) 
репозиторий на GitHub, клонировать уже Вашу копию локально, создать новую ветку, 
внеси изменения (например,исправить баг или добавить фунционал), запушить ветку и 
создать [pull request](https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/creating-a-pull-request).
Далее последует некоторое обсуждение с разработчиками проекта, и Вы получите
фидбек на Ваши изменения. В итоге, если все сложится благополучно, Ваши изменения
будут смерджены в оргинальный (upstream) репозиторий. Как правило, у больших проектов
существует гайд для участия, проблемы (issues) с пометкой beginner-friendly (для новичков),
а некоторые даже имеют менторские программы, помогающие новичкам ознакомиться с проектом.
